<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="lib/vue.js"></script>
    <link rel="stylesheet" href="lib/picnic.min.css" />
    <title>AMC Parasite</title>
    <style>
        /* main */
        h1 a {
            cursor: pointer;
        }
        body { /* night mode */
            background: #000020;
            filter: invert(100%);
        }
        .debug {
            height: 300px;
            overflow-y: scroll;
            resize: both;
        }
        .current-menu {color: black;}


        /* unclassified */

        .user {
            border: 5px solid darkgrey;
        }
        .user span {
            font-weight: bold;
        }
        a {
            color: #42b983;
        }

        .annotated-box, .scans {
            display: inline-block;
        }
        .annotated-box img {
            margin-bottom: 2em;
        }
        .annotated-box img, .scans img {
            height: 2.5em;
        }
        .hide-character-annotation .annotated-box img {
            margin-bottom: 0; /* override */
        }
        .hide-character-annotation .annotated-box .annotation {
            display: none;
        }
        .annotated-box .annotation {
            display: inline-block;
            width: 0;
            position: relative;
            left: -1em;
        }
        .unguessed {
            border: 1px solid black;
            padding: 3px;
            margin: 0 2px;
        }
        .unguessed.current {
            border-color: red;
        }

        #toggle:checked ~ .offOnToggle { display: none; }

        .img1em img { height: 1em; }
        .group { border-right: 2px solid black; }

        .for-miniset .sample { display: inline-block; text-align: center; }
        .current-miniset .sample { display: inline-block; border: 1px solid black; cursor: crosshair; text-align: center;}
        .leftborder { border-left: 10px solid yellow !important;}
    </style>

    <script type="text/x-template" id="component-exam-grade">
        <div class="exam-grade">
            {{status}}
            <button @click="load_yaml_config()">(re)load config.yaml</button>
            <select v-if="cfg.fields" v-model="currentField">
                <option v-for="(o,i) in fieldStringId" :value="i">{{o}}</option>
            </select>
            <label style="margin-left: 10em">
                <input type="checkbox" v-model="showAnnotations"/>
                <span>Show Annotations</span>
            </label>
            <div class="for-table img1em" v-if="currentFieldDescription && boxes !== {}">
                <table :class="{'sorting-table':true, 'hide-character-annotation': !showAnnotations}" ref="table">
                    <thead>
                    <tr>
                        <th v-for="e in currentFieldDescription.propositions" :key="'th'+e"
                        :style="'width:'+(100/currentFieldDescription.propositions.length)+'%'"
                        :class="{ ok: currentFieldDescription.ok === e }"
                        >|{{ e }}|</th>
                    </tr>
                    </thead>
                    <tr v-for="(group, u) in boxes" :key="group.blob + '--' + u" :class="{current: orderedUsers[currentUser] === u}">
                    <td v-for="e in currentFieldDescription.propositions" :key="'td'+e">
                        <span v-if="guess[currentField][u] === e" class="">
                            <span v-for="r in group.group.rows" :key="'character'+r[2]" class="annotated-box">
                                <img :src="r[13]" /><span class="annotation">{{r[12]}}</span>
                            </span>
                        </span>
                    </td>
                    </tr>
                </table>
            </div>
          

            <pre>{{JSON.stringify(guess)}}</pre>
            <ul>
                <li v-for="b in boxes">{{b}}</li>
            </ul>
            <pre>{{JSON.stringify(currentFieldDescription)}}</pre>
        </div>
    </script>

    <script type="text/x-template" id="component-exam-identify">

        <div class="exam-identify">
            <button @click="load_info()">load config.yaml / parasite.xlsx</button><br/>
            <button @click="iterateGuess()">do guess</button><br/>
            <button @click="save_xlsx()">...save</button><br/>

            Unguessed : <button @click="currentUnguessed--">«</button><input style="width: 3em; text-align: center" v-model="currentUnguessed"/><button @click="currentUnguessed++">»</button><br/>
            <span v-for="u in unguessed"
                :class="{unguessed: true, current: u===currentUnguessed}"
                :key="'ung'+u"
                @click="currentUnguessed = u"
                @click.right.prevent="focus('cr/page-'+u+'-'+boxes[u].groups[0].rows[0][4]+'.jpg')"
                >{{u}}</span>
            <hr/>

            <div v-if="boxes[currentUnguessed] !== undefined" class="img1em">
                <br/>
                <span v-for="group in boxes[currentUnguessed].groups" :key="'ungg'+group.blob" class="group">
                    <span v-for="r in group.rows" :key="'unggg'+r[2]" class="annotated-box">
                    <img :src="r[13]" />
                    <span class="annotation">{{r[12]}}</span>
                    </span>
                </span>
            </div>
            
            <div v-if="false" class="all-boxes img1em">
                <div v-for="(log, u) in raw_boxes" :key="u">
                    {{u}}: <img v-for="r in log" :key="r[2]" :src="r[13]"/>
                </div>
            </div>

            <input type="checkbox" id="toggle" />
            <label for="toggle" class="checkable">
                Show only unguessed
            </label>
            <div v-for="(row,i) in data_rows" :key="i" :class="{offOnToggle: guess[i] !== undefined}">
                <span :class="{unguessed: guess[i] === undefined}" @click="affect_user_to_row(currentUnguessed, i)">[ {{i}} ]</span>
                <span>{{ row[1] }}</span> --
                <span>{{ row[2] }}</span>
                ⇒
                <span v-if="guess[i]" class="img1em">
                    <a href=" " @click.prevent="addGuessToMiniset(boxes[guess[i]], row, guess[i], i)">[add-all]</a>
                    {{ guess[i] }}
                    <span v-for="group in boxes[guess[i]].groups" :key="group.blob">
                        <span v-for="r in group.rows" :key="r[2]" class="scans">
                            <img :src="r[13]" />
                        </span>
                    </span>
                </span>
            </div>

            <label>
                <input type="checkbox" v-model="displayForMiniset"/>
                <span class="checkable">For miniset review</span>
            </label>
            <div v-if="displayForMiniset" class="for-miniset">
                <div v-for="(row,i) in data_rows" :key="i">
                    <div v-if="guess[i] !== undefined" class="img1em">
                        <a href=" " @click.prevent="addGuessToMiniset(boxes[guess[i]], row, guess[i], i)">[add-all]</a>
                        <div v-for="anno in makeListForMiniset(boxes[guess[i]], row)"
                             class="sample">
                             <span v-if="anno == 'ENDGROUP'" style="display: inline-block; width: 5em;"></span>
                             <span v-else>
                                {{anno[0]}}<br/><img :src="anno[1][13]"/>
                            </span>
                        </div>
                   </div>
                </div>
            </div>

            
            <pre class="debug">{{data_rows}}</pre>
            <pre class="debug">{{cfg}}</pre>
        </div>
    </script>


</head>
<body>
    <div id="main">
        <h1>AMC Parasiting: {{project_path}}
            <a v-for="(v,k) in {identify: 'Id', grade: 'Grade'}" :class="{'current-menu': tab=='exam-'+k}" @click="tab = 'exam-'+k">[{{v}}]</a>
        </h1>

        <exam-identify v-if="tab == 'exam-identify'" :project_path="project_full_path" @add-to-miniset="miniset.push($event)"></exam-identify>
        <exam-grade v-if="tab == 'exam-grade'" :project_path="project_full_path" @add-to-miniset="miniset.push($event)"></exam-grade>

        <hr/>
        <div class="current-miniset">
            <div v-for="anno,ia in sortedMiniset"
                :class="{sample: true, leftborder: ia>0 && anno[0] != sortedMiniset[ia-1][0]}"
                @click="removeFromMiniset(anno)"
                >
                {{anno[0]}}<br/><img :src="anno[1][13]"/>
            </div>
            <a class="button" @click="saveCurrentMiniset()">Save Miniset</a>
            <br/>{{project_path}}
        </div>
        <pre class="debug">{{debug_logs}}</pre>
    </div>    

    <script src="lib/vuejspython.js"></script>
    <script src="suggestions.js"></script>
    <script>

    vuejspython.component('ExamGrade', 'exam-grade', {
        template: '#component-exam-grade',
        data: () => ({
            currentField: 13,
            currentUser: 0,
            showAnnotations: false,
            guess: [], // field -> user -> guess
            status: 'Loading...',
        }),
        mounted() {
            // hum vuejspython setup is actually async it seems -> should look at async components to be better integrated I think
            setTimeout(()=> this.doInit(), 1000)
            this.guess[this.currentField] = {}
        },
        watch: {
            /*currentField(f) {
                console.log("FIELD",f)
                if (!(f in this.guess)) {
                    this.guess[f] = {}
                }
            },*/
            boxes(boxes) {
                if (boxes === undefined) return
                if (boxes === {}) return
                if (this.currentFieldDescription === null) return
                if (boxes[this.currentField] === undefined) return

                if (!(this.currentField in this.guess)) {
                    this.guess[this.currentField] = {}
                }
                let g = this.guess[this.currentField]
                let props = this.currentFieldDescription.propositions
                let first = props[0]
                suggestions = {DEFAULT: props}
                for (let u of Object.keys(boxes)) {
                    if (!(u in g)) {
                        //g[u] = first
                        const bg = S.bestGuess(boxes[u].group, suggestions)
                        if (bg === null) {
                            // empty answer
                        }
                        const [sug, imax, dists] = S.bestGuess(boxes[u].group, suggestions)
                        g[u] = props[imax]
                    }
                }
            },
        },
        computed : {
            noCfg() {
                return this.cfg.fields === undefined
            },
            fields() {
                if (this.noCfg) return []
                return this.cfg.fields.more
            },
            fieldStringId() {
                return this.fields.map(o => o.name + (o.boxes.length>0 ? JSON.stringify(o.boxes) : '')) // set threshold to 1 to have cleaner names sometimes
            },
            currentFieldDescription() {
                if (this.noCfg) return null
                return this.fields[this.currentField]
            },
            boxes() {
                if (this.noCfg) return {}
                if (typeof this.raw_boxes === 'undefined') return {}
                let qId = this.currentFieldDescription.boxes[0]
                let data = this.raw_boxes[qId]
                if (data === undefined || data === []) {
                    this.status = 'Waiting for boxes for '+qId
                    this.load_boxes(qId)
                    return // wait for this.raw_boxes to be loaded for this key
                }
                this.status = ''
                let get = (d, name, q, min = 0, max = undefined) => ({ name, blob: name + '--' + q + '--' + min + '--' + max, rows: d.filter(r => r[7] === q).slice(min, max) })
                let boxes = {}
                Object.keys(data).forEach(u => {
                    let d = data[u]
                    boxes[u] = {
                        student: u,
                        group: get(d, this.fieldStringId[this.currentField], ...this.currentFieldDescription.boxes),
                    }
                })
                return boxes
            },
            orderedUsers() {
                return Object.keys(this.boxes)
            },
        },
        methods: {
            doInit() {
                this.load_yaml_config()
            },
        },
    })

    vuejspython.component('ExamIdentify', 'exam-identify', {
        template: '#component-exam-identify',
        data: () => ({
            currentUnguessed: 1,
            displayForMiniset: false,
        }),
        computed: {
            boxes: function() {
                let data = this.raw_boxes
                let get = (d, name, q, min = 0, max = undefined) => ({ name, blob: name + '--' + q + '--' + min + '--' + max, rows: d.filter(r => r[7] === q).slice(min, max) })
                let boxes = {}
                //this.unguessed = {}
                Object.keys(data).forEach(u => {
                    let d = data[u]
                    boxes[u] = {
                        student: u,
                        groups: [
                            get(d, 'firstname', ...this.cfg.fields.firstname),
                            get(d, 'lastname', ...this.cfg.fields.lastname)
                        ]
                    }
                })
                return boxes
            },
            unguessed: function() {
                let ung = JSON.parse(JSON.stringify(Object.keys(this.boxes)))
                for (let i in this.guess) {
                    ung.splice(ung.indexOf(this.guess[i]), 1)
                }
                return ung
            },
        },
        methods: {
            makeListForMiniset(bo, row) {
                let targets = [row[1].toUpperCase(), row[2].toUpperCase()] // this is the non-generic line
                let res = []
                for (let gi in bo.groups) {
                    let g = bo.groups[gi]
                    let t = targets[gi]

                    let i = 0
                    let j = 0
                    while (i < t.length && j < g.rows.length) {
                        while (j < g.rows.length && g.rows[j][12] == '_') j++
                        if (j < g.rows.length) {
                            res.push([t[i], g.rows[j]])
                        }
                        i++
                        j++
                    }
                    res.push('ENDGROUP')
                }
                return res
            },
            addGuessToMiniset(bo, row, _g, _i) {
                for (let ev of this.makeListForMiniset(bo, row)) {
                    if (ev == 'ENDGROUP') continue;
                    this.$emit('add-to-miniset', ev)
                }
            },
            iterateGuess() {
                this.fillGuesses([...Object.values(this.guess)], (o, i) => this.guess[i] !== undefined ? null : o)
            },
            fillGuesses(skip = [], filt = o => o) {
                let upper = v => v === null ? null : v.toUpperCase()
                let suggestions = {
                    firstname: this.data_rows.map(o => upper(o[1])).map(filt),
                    lastname: this.data_rows.map(o => upper(o[2])).map(filt)
                }
                console.log(suggestions)
                for (let k in this.boxes) {
                    if (skip.indexOf(k) !== -1) continue
                    let guessFirstname = S.bestGuess(this.boxes[k].groups[0], suggestions)
                    let guessLastname = S.bestGuess(this.boxes[k].groups[1], suggestions)
                    let ok = false
                    if (guessFirstname !== null && guessLastname !== null) {
                        if (guessFirstname[1] === guessLastname[1] || suggestions.firstname[guessLastname[1]] === guessFirstname[0]) {
                            if (this.guess[guessLastname[1]] === undefined || this.guess[guessLastname[1]] === k) {
                                this.affect_user_to_row(k, guessLastname[1])
                                ok = true
                            }
                        }
                    }
                    if (!ok) {
                        if (guessFirstname === null) guessFirstname = [-1, -2, -3]
                        if (guessLastname === null) guessLastname = [-1, -2, -3]
                        console.log(k, ':', guessFirstname[1] === guessLastname[1], guessFirstname[1], guessLastname[1], guessFirstname[0], guessLastname[0])
                        //this.unguessed[k] = { k, log: [k, ':', guessFirstname[1] === guessLastname[1], guessFirstname[1], guessLastname[1], guessFirstname[0], guessLastname[0]] }
                    }
                }
            },

        }
    })
    
    vuejspython.start({
        data: () => ({
            tab: 'exam-grade',
            miniset: [],
        }),
        methods: {
            removeFromMiniset(anno) {
                let i = this.miniset.map(a => a[1][13]).indexOf(anno[1][13])
                if (i != -1) {
                    this.miniset.splice(i, 1)
                }
            },
            saveCurrentMiniset() {
                this.save_miniset(this.miniset.map(anno => [anno[0], anno[1][13]]))
            },
        },
        computed: {
            sortedMiniset() {
                let res = [...this.miniset]
                res.sort((a, b) => a[0].localeCompare(b[0]))
                return res
            },
        },
    })
    </script>
</body>
</html>

